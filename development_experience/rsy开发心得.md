其实有好多积累的经验，感觉太多了还是记录下来比较好。
但是目前感觉会分散在各个角落，这个就相当于是个索引了吧。   
经验包括但不限于：数据结构与算法，设计模式，分布式系统，体系结构，操作系统内核，数据库，面向对象程序设计，泛型程序设计，元编程，函数式程序设计，一些具体的语言特性方面的设计，还有设计中各个方面的 **trade-off** 。   

本人才疏学浅，对这些设计也只是泛泛而谈。   

## 2018-07-26 ##
在移植红黑树的过程中，才发现之前把迭代器的 `operator--` 内部的 `decrement` 有问题。   
原因是：为了让 `decrement` 好写，我做了一个改动，也就是让 `NIL` 的父节点是 `root` 结点。但是在其他操作中忘记维护这个性质了。   
目前想了2个Solution：  

- 在每次 `root` 结点变动时，维护这一性质，事实上我就是这么做的。
- 受那啥影响，我现在总是喜欢写的复杂。于是这个地方就可以引入 "lazy evaluation" ，但是我把迭代器和红黑树的实现解耦了，所以每次使用  `operator--` 的时候都要通知红黑树，这又是一个大问题：封装与效率（通常是并行）的冲突。虽说封装利于系统开发，但是如果某些模块互相可见的话，还是会提高不少效率。

另外，又碰到一个问题：  
**资源管理：由谁生成，由谁释放。**   
这个问题太过于棘手，尤其是牵扯到在不同的模块之间，而且还有不同的开发者之间的配合。写 C 还没有 C++ 的 `std::shared_ptr<T>` 那样随意。   
由于 C 没有 `copy ctor` ，那只能由我这个库作者来释放，另外还得考虑到各种 **UB** ，真是累死我了。   


##   ##




##   ##

