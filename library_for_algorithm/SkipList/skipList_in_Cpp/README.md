skiplist 实现策略感觉众说纷纭，我也不知道哪种比较好。   

-----

我的实现策略：  [SkipList - YouTube](https://www.youtube.com/watch?v=7GWXfL6T3fM)  

结构是用很多 row 来组成整个跳表，用一个 list 来存储每个 row 的 head 和 row 的 size。

- 上面的 row 一定是下面 row 的**子集**。
- 每个 row 都是有序的。
- 查找时，尽可能地向右，然后向下。
- 插入时，找到底层该插入的位置，然后选一个随机值作为高度，将其抬高这么多层。
- 删除时，找到最上面的那个 node，然后一路向下删除。
- 我写了一个小回收器：每隔一段操作之后会触发，如果两行之间 size 的比大于某一给定数值，那么删除上面那一整行。

再一次熟练了代理模式，区分读和写，k-v 存储也写得越来越多，感觉有点意思了。这次是手动管理内存，没有交给智能指针，所以终于可以用 nil 结点而且不要求 value 有默认构造器了（弥补了之前写 map 的遗憾）。另外熟悉了一下完美转发在构造器中的运用（除了我现在的写法以外还有一种策略是传值，然后 move）。

&nbsp;  
写完了发现一些缺点，感觉我就是个**智障**。

- node copy，这个完全不需要，只需要一个索引就好。浪费了大量空间和时间，而且本来可以转发的。
- 跳表的实现策略感觉很多，我写完感觉我写的这个比较蠢了。测试了一下，和 `std::map` 的时间差大概在5-10倍，太蠢了。
- 其实可以在每个节点存一个链表，指向之后的，which 让我想到了 AOS & SOA。
- 回收方面我不是很懂，凑活写了一个，好像并没有提升效率。  

主要就是2个地方：  
1. 指针和链表的结构组织，当然真正的 node 只有一个。   
2. 适当回收 row，来提高效率。（在写这个的时候突然想到一种 lazy 策略，要回收的时候，直接把 row 从链表中提出来，放入回收容器中，然后把回收的消耗均摊到其他操作中。）

